# N X N 크기의 공간에
# 물고기 M
# 아기 상어 1마리
# 한칸에는 물고기가 최대 1마리 존재한다.
# 물고기 크기 정보 있고 초기 아기 상어의 크기는 2이다.
# 1초에 상하좌우로 인접하 칸을 이동 가능하다.
# 아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고,
# 나머지 칸은 모두 지나갈 수 있다. 
# 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 크기가 같은 물고기는 먹을 수 없지만 지나갈 수 있다.

# 먹을 물고기가 없다면 아기 상어는 엄마를 호출
# 먹을 수 있는 물고기가 오직 한마리이면 해당 물고기를 먹으로 간다.
# 먹을 수 있는 물고기가 1마리보다 많다면 거기가 가장 가까운 물고기를 먹으러 간다.
# 거리는 상어 위치에서 물고기가 있는 칸으로 이동할때 지나가야하는 칸의 갯수의 최소값 -> 맨하튼 거리 측정 공식 사용
# 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면 가장 외쪽에 있는 물고기를 먹는다.
# 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.
# 마리수가 축적되어 크기보다 커지면 1 증가
# 몇 초동안 엄마 상어를 요청하지 않고 물고기를 잡아 먹을 수 있는지 구하여라.
# 0: 빈 칸
# 1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기
# 9: 아기 상어의 위치
# 4 3 9 0
# 0 0 0 0
# 0 0 0 0
# 0 0 3 4

# 3 6 1 4
# 2 2 3 3
# -------
# 0 0 1
# 0 0 0
# 0 9 0
import sys

def distance(x1,y1, x2,y2):
    w = abs(x1 - x2)
    h = abs(y1 - y2)
    return w+h
n =4
graphs = []
sharck = 0
pratice = ['4 3 2 1','0 0 0 0','0 0 9 0','1 2 3 4']
default_search = []
for i in range(n):
    # v = list(map(int,sys.stdin.readline().strip().split()))
    v = list(map(int,pratice[i].split()))
    for j in range(n):
        if v[j] == 9:
            sharck = [(i,j),2]
            v[j] = 2
        if v[j] ==1:
            default_search.append([(i,j),1])
        graphs.append([(i,j),v[j]])

print(graphs)
graphs.sort(key=lambda x: x[0][0])
graphs.sort(key=lambda x: x[1])
print(graphs)
print(graphs.index(sharck))
